{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#litecrypt","title":"Litecrypt","text":"<p>Library that provides a simple solution for encrypting and decrypting files and messages, as well as keeping track of them.</p>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#encrypting-data","title":"Encrypting data","text":"<pre><code>from litecrypt import Crypt , gen_key\n\nkey = gen_key()\n\ndata = b'some random data'\nmessage = 'some random message'\n\nencrypted_data = Crypt(data,key).encrypt()\nencrypted_message = Crypt(message,key).encrypt()\n\nmessage_again = Crypt(encrypted_message,key).decrypt()\nprint(message_again)\n</code></pre>"},{"location":"#encrypting-files","title":"Encrypting Files","text":"<pre><code>from litecrypt import CryptFile, gen_key\n\n# Create a file to see how it works\nCryptFile.make_file(filename='notes.txt',content='hello there')\n\nkey = gen_key()\nCryptFile('notes.txt',key=key).encrypt(echo=True)\nCryptFile('notes.txt.crypt',key=key).decrypt(echo=True)\n# echo, to display progress in the console\n</code></pre>"},{"location":"#database-usage","title":"Database usage","text":"<p>Let's say we have 3 files: <code>file</code>, <code>image.png</code>, and <code>notes.txt</code> in a directory called <code>test</code>:</p> <pre><code>files = ['test/file', 'test/image.png', 'test/notes.txt']\n</code></pre> Click me to make them <pre><code>import os\nfrom litecrypt import CryptFile\n\n# Create a directory for testing\nos.mkdir('test')\n\n# Create sample files\nfiles = ['test/file', 'test/image.png', 'test/notes.txt']\nfile_contents = [b'some data', b'binary data of some image', b'some notes']\n\nfor file, content in zip(files, file_contents):\n    CryptFile.make_file(filename=file, content=content)\n\n# The files now exist in the directory test/\n</code></pre> <p>Leave the files in there, take a copy of their content, encrypt it, and store it in a database. You never know when you'll need them.</p> Collect the content <pre><code>file_contents = []\nfor file in files:\n    file_content = CryptFile.get_binary(file)\n    file_contents.append(file_content)\n</code></pre> Encrypt each file content <pre><code>from litecrypt import Crypt, gen_key\n\nkey = gen_key()\nencrypted_contents = []\nfor content in file_contents:\n    encrypted_content = Crypt(content, key).encrypt(get_bytes=True)\n    encrypted_contents.append(encrypted_content)\n</code></pre> <p>With a copy of the content encrypted we need storage</p> <pre><code>from litecrypt import Database, gen_ref\n\n# Create &amp; connect to the databases (sqlite for now)\nmain_db = Database('secure_vault.db')\nkeys_db = Database('secure_vaultKeys.db',for_keys=True)\n\n# Generate a key reference value to link up the two databases with\nkey_ref = gen_ref()\n\n# Insert encrypted content and keys into the databases\nfor file, encrypted_content in zip(files, encrypted_contents):\n    main_db.insert(filename=f'does-not-matter/{file}.crypt', content=encrypted_content, ref=key_ref)\n    keys_db.insert(filename=f'does-not-matter/{file}.crypt', content=key, ref=key_ref)\n# Add .crypt to indicate they're encrypted\n</code></pre> <p>Done! The files are still in <code>test/</code>, but you now have encrypted copies of them in the main database. The keys used for encryption are stored in the keys database. You can encrypt your keys database too, but for this demo, let it be as is.</p> <p>\u2708\ufe0f  You're somewhere else now. How do you get the files back? Let's simulate this by creating another directory, which we'll call <code>spawned</code>: <pre><code>os.mkdir('spawned')\n</code></pre> Now, retrieve the files:</p> <pre><code>from litecrypt import spawn\n\nmain_db = ... #  your Database connection instance\nkeys_db = ... # Your Database connection instance for keys\nkey_ref = ... # The reference value used for the file/key combo used\n\nspawned = spawn(main_connection=main_db,\n                       keys_connection=keys_db,\n                       key_reference=key_ref,\n                       directory='spawned',\n                       get_all=True,\n                       echo=True)\n</code></pre> <p>That's it! They exist now in the 'spawned/' directory, encrypted though like we put them.</p> <p>How about we decrypt them ?</p> <p><pre><code>for file, key in zip(spawned['filenames'], spawned['keys']):\n    CryptFile(file, key).decrypt(echo=True)\n</code></pre> The files are retrieved and decrypted. Check if the files in <code>test/</code> match the files in <code>spawned/</code>.</p> Here's the full demo <pre><code>import os\n\nfrom litecrypt import Crypt, CryptFile, Database, gen_key, gen_ref, spawn\n\n# Create a directory for testing\nos.mkdir(\"test\")\n\n# Create sample files\nfiles = [\"test/file\", \"test/image.png\", \"test/notes.txt\"]\nfile_contents = [b\"some data\", b\"binary data of some image\", b\"some notes\"]\n\nfor file, content in zip(files, file_contents):\n    CryptFile.make_file(filename=file, content=content)\n\n# The files now exist in the directory test/\n\n# Collect each file's content\nfile_contents = []\nfor file in files:\n    file_content = CryptFile.get_binary(file)\n    file_contents.append(file_content)\n\n# Encrypt each file's content one by one\nkey = gen_key()\nencrypted_contents = []\nfor content in file_contents:\n    encrypted_content = Crypt(content, key).encrypt(get_bytes=True)\n    encrypted_contents.append(encrypted_content)\n\n# Initialize the main &amp; the associated keys database\nmain_db = Database(\"secure_vault.db\")\nkeys_db = Database(\"secure_vaultKeys.db\",for_keys=True)  # Specify it's for keys\n\n# Generate a key reference value to link up the two databases with\nkey_ref = gen_ref()\n\n# Insert encrypted content and keys into the databases\nfor file, encrypted_content in zip(files, encrypted_contents):\n    main_db.insert(\n        filename=f\"does-not-matter/{file}.crypt\", content=encrypted_content, ref=key_ref\n    )\n    keys_db.insert(filename=f\"does-not-matter/{file}.crypt\", content=key, ref=key_ref)\n# Add .crypt to indicate they're encrypted\n\n# Create another directory\nos.mkdir(\"spawned\")\n\n# The files will now pop into existence in this new directory\nspawned = spawn(\n    main_connection=main_db,\n    keys_connection=keys_db,\n    key_reference=key_ref,\n    directory=\"spawned\",\n    get_all=True,\n    echo=True,\n)\n\n# Decrypt them\nfor file, key in zip(spawned[\"filenames\"], spawned[\"keys\"]):\n    CryptFile(file, key).decrypt(echo=True)\n</code></pre>"},{"location":"#supported-databases","title":"Supported Databases","text":"<p>The library currently supports: MySQL, PostgreSQL and SQLite.</p> <p>Note: The GUI only support SQLite</p>"},{"location":"#how-to-connect","title":"How To Connect ?","text":"<p>SQLite: Specify the file name of the database, it must end with either <code>.db</code> or <code>.sqlite</code> <pre><code>from litecrypt import Database\nmain_connection = Database('test.db')\nkeys_connection = Database('somekeysdatabase.db',for_keys=True)\n</code></pre> By default, every database connection defaults to main, set the parameter <code>for_keys=True</code> to let the underlying process know this is used for keys, this is mando to retrieve files based on reference.</p> <p>PostgreSQL:  Plug in the coordinates  as the url. <pre><code>from litecrypt import Database\n\nmain_conn = Database(url='username:password@host:port/database',\n                     engine_for='postgres',\n                     echo=True)\n</code></pre> The echo parameter is optional, it shows what's happening behind the scenes.</p> <p>MySQL: Same as PostgreSQL except the engine is different. <pre><code>from litecrypt import Database\n\nmain_conn = Database(url='username:password@host:port/database',\n                     engine_for='mysql',\n                     echo=True)\n</code></pre></p>"},{"location":"#why-use-reference","title":"Why Use Reference ?","text":"<p>The reference value, such as <code>#8jX?7c</code>, remains independent of both the encrypted data and the encryption keys. It does not reveal any information about the keys used or the encrypted data itself. Instead, its purpose is to establish a connection between the two databases, consistently linking each file to its corresponding key.</p> <p>The primary database holds the filenames and their encrypted data, while the keys database stores the filenames and the keys used to encrypt them. To recover files, both databases need to be simultaneously accessible. However, a crucial point to note is that robust security for the keys database is necessary only when BOTH databases are accessible together.</p> <p>If someone gets hold of the main database, they'll only get dog shit. Trying to break the content would be really hard. On the other hand, if someone only accesses the keys database, they'll only find keys and filenames. It won't help much.</p> <p>You can keep the databases separate (though that might be hard and impractical) or make copies of your main database\u2014regardless of your level of trust in the system you place them in.</p> <p>In this situation, the keys database should be kept safe, preferably encrypted. When you want your files back, get your main database from wherever you stored it. Then, use the keys database to unlock the files you need.</p> <p>The process of getting files back really simple, actually it's just one function called <code>spawn()</code></p>"},{"location":"#all-in-one-app","title":"All In One App","text":"<p>Wait... Install the library first</p>"},{"location":"docs/","title":"Documentation","text":""},{"location":"docs/#hold-on-champ","title":"Hold on champ..","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#library-installation","title":"Library installation","text":"<p>You can simply use pip</p> <pre><code>pip install litecrypt\n</code></pre> <p>After the library is installed  You can run the GUI right away</p> <pre><code>python -m litecrypt\n</code></pre> <p>Note: Make sure you have Python 3.8 or newer for the app &amp; library to work properly.</p> <p></p>"}]}